<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="./css/style.css">
        <script src="js/src/stats.min.js"></script>

    </head>
    <body>
<div id ='but'>
        <div id = "circle"></div>
        <div id = "innercircle"></div>
        <p> hello</p>
   </div>
        <script src="js/src/three.js"></script>
        <script src="./js/app.js" async defer></script>

        <!-- <canvas id = 'bannerCanvasStatic' ></canvas> -->

        <canvas id = 'bannerCanvas' ></canvas>
        <button onclick="doThing()">press me</button>
        <script id="vertexShader" type="notjs">
        const float TWO_PI = 6.2831855;
        varying vec2 vUv;
        varying vec2 vUvStraight;

        uniform float u_test;
      // uniform float u_time;
        uniform float mx;
        uniform float my;

        uniform vec2 u_resolution;


        void main() {
            float u_time = 0.;
            vUv = uv;
            vUvStraight = uv;

            vec2 texcoord = uv * u_resolution;
   float mixX =  mx*2.0;
   float mixY =my*5.0;
    

            float spoint =((((sin(u_time ))* 0.17*uv.x)  + (sin(uv.y *1.2 * TWO_PI +u_time ) * 0.2))+ 0.4 );
          //  <!-- vUv = vec2(spoint+(sin(uv.x * u_time * 3.  ) * 5. )); -->
            vUv = vec2(mix(spoint+(sin(uv.x * u_time * 3.  ) * 5.  ),uv.x, mixX) , uv.y);//mix(texcoord.y+(cos(uv.y * u_time * 2.  ) * 5. ),uv.y, mixY) );
            vec3 pos = position;
          //  <!-- pos.y = position.y * 1.0 -(u_test * (sin(uv.x * TWO_PI))); -->
            gl_Position = projectionMatrix *
                           modelViewMatrix *
                           vec4(pos,1.0);
           }
           
           </script>
           
           <script id="fragmentShader" type="notjs">
            const float TWO_PI = 6.2831855;

            uniform sampler2D texture1;
            uniform float u_test;
            uniform float u_time;
            varying vec2 vUv;
            varying vec2 vUvStraight;
           
            uniform vec2 u_resolution;

            uniform float mx;
        uniform float my;

            float notRand(vec2 co)
            {
             return (dot(sin(co.x * TWO_PI + u_time ), cos(TWO_PI * co.y + u_time)));
            }

            float dist (vec2 a, vec2 b){

              return sqrt( ((a.x -b.x) * (a.x - b.x)) + ((a.y -b.y) * (a.x - b.y)) );
            }
            void main() {
                float MX = mx - 0.5;
                float MY = my - 0.5;
                float borderWidth = u_resolution.x * 0.1;
                vec2 st = vUv;
                vec4 col;
               // if(( (  vUvStraight.x > 0.2 && vUvStraight.x < 0.21 ) || (vUvStraight.x > 0.79 && vUvStraight.x < 0.8)) && (vUvStraight.y > 0.2 && vUvStraight.y <0.8)
               // || ( (  vUvStraight.y > 0.2 && vUvStraight.y < 0.21 ) || (vUvStraight.y > 0.79 && vUvStraight.y < 0.8)) && (vUvStraight.x > 0.2 && vUvStraight.x <0.8) ){
              //      col = vec4(1.0);
              //  }else{
                st.x += notRand(vUv) * MX;
                st.y+= notRand(vUv) *MY;
                

                col = texture2D(texture1, st);
               // col.x +=  (dist(st, vUvStraight) )  > 0. ? (dist(st, vUvStraight) * 1.2) : 0.  ;
                //}

                gl_FragColor = col;
                //gl_FragColor = vec4(st.x,  st.x, st.x,1.0); // A
              }
           </script>
    </body>
</html>

    </body>
</html>